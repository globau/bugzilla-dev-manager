#!/usr/bin/perl

use strict;
use warnings;

#

use lib '/opt/bugzilla/repo/git/bugzilla-dev-manager';

#

use BugzillaDev;
use BugzillaDevConfig;
use CGI;
use Cwd qw(abs_path cwd);
use File::Basename;
use File::Copy;
use File::Copy::Recursive qw(dircopy);
use File::Find;
use FileHandle;
use File::Path qw(remove_tree);
use File::Slurp;
use Pod::Text::Ansi;
use Storable qw(dclone);
use Test::Harness qw(&runtests);

my $action = lc(shift @ARGV || '');

if ($action eq 'new') {
    my $subdir = validateSubdir(shift @ARGV);
    if (-e "$HTDOCS_PATH/$subdir/localconfig") {
        die "$HTDOCS_PATH/$subdir already exists\n";
    }

    if (!scalar @ARGV) {
        unshift @ARGV, determineDefaultRepo($subdir);
    }
    my $repo = validateRepo(shift @ARGV);

    if (!scalar @ARGV) {
        unshift @ARGV, determineDefaultDatabase($subdir);
    }
    my $database = validateDatabase(shift @ARGV);

    if (!databaseExists($database, %LOCALCONFIG)) {
        exit unless confirm("the database '$database' does not exist, continue?");
    }
    info("creating $subdir");
    info("using repo $repo");
    info("using database $database");
    updateRepo($repo);
    createSubDir($subdir, $repo);
    updateLocalConfig($subdir, $database);
    fixParams($subdir);
    fixHtAccess($subdir);
    pushd("$HTDOCS_PATH/$subdir");
    system "./checksetup.pl -t";
    system "./checksetup.pl";
    popd();
    fixSubDir($subdir);
    info("$subdir created\n" . getDirSummary($subdir, 1));

} elsif ($action eq 'patch') {
    my ($subdir, $repo);
    eval { $subdir = getCurrentSubdir() };
    if ($@) {
        eval { $repo = getCurrentRepoPath() };
    }
    if ($subdir) {
        my $patch = validatePatch($subdir, @ARGV);
        info("patching $subdir with #$patch");
        deploySubdirPatch($subdir, $patch);
    } elsif ($repo) {
        my $bugId = shift @ARGV
            or die "bug number required\n";
        my $patch = validatePatch($bugId, @ARGV);
        deployRepoPatch($repo, $patch);
    } else {
        getCurrentSubdir();
    }

} elsif ($action eq 'new-patch') {
    my $subdir = getCurrentSubdir();
    info("about to revert all current changes and apply a new patch");
    my $patch = validatePatch($subdir, shift @ARGV);
    info("patching $subdir with #$patch");

    system "$0 unfix";
    system "bzr revert";

    my $in_unknown = 0;
    foreach my $line (`bzr st`) {
        chomp $line;
        if ($line =~ /^unknown:/) {
            $in_unknown = 1;
            next;
        }
        next unless $in_unknown;
        last unless $line =~ /^\s+(.+)$/;
        my $file = $1;
        print "deleting $file\n";
        if (-d $file) {
            remove_tree($file) or die $!;
        } else {
            unlink($file) or die $!;
        }
    }

    system "$0 fix";
    deploySubdirPatch($subdir, $patch);

} elsif ($action eq 'diff') {
    my $subdir = getCurrentSubdir();
    my $quick = grep { $_ eq '-quick' } @ARGV;
    @ARGV = grep { $_ ne '-quick' } @ARGV;
    my $bug = shift || $subdir;
    my @files = @ARGV;
    if (!$quick) {
        info("running tests");
        my @missing;
        my @added = getAddedFiles($subdir);
        foreach my $file (@added) {
            if (isMissingBoilerPlate("$HTDOCS_PATH/$subdir/$file")) {
                push @missing, $file;
            }
        }
        if (scalar @missing) {
            foreach my $file (@missing) {
                print "$file does not contain a boilerplate\n";
            }
            exit unless confirm("continue?");
        }
        checkForTabs($subdir);
        runTests($subdir, 2, 4, 5, 8, 9, 10);
    }
    info("making patch");
    diff($subdir, $bug, @files);

} elsif ($action eq 'db') {
    my $subdir = getCurrentSubdir();
    if (scalar @ARGV) {
        my $database = validateDatabase(shift @ARGV);
        if ($database eq getCurrentDatabase($subdir)) {
            info("the current database is already $database");
            exit;
        }
        updateLocalConfig($subdir, $database);
        getDbh($subdir);
        fixParams($subdir);
    } else {
        info(sprintf("current database for %s is %s", $subdir, getCurrentDatabase($subdir)));
    }

} elsif ($action eq 'fix') {
    my ($subdir, $repo);
    eval { $subdir = getCurrentSubdir() };
    if ($@) {
        eval { $repo = getCurrentRepoPath() };
    }
    if ($subdir) {
        info("fixing $subdir");
        fixSubDir($subdir);
    } elsif ($repo) {
        info("fixing $repo");
        fixRepo($repo);
    } else {
        getCurrentSubdir();
    }

} elsif ($action eq 'disable-bugmail') {
    my $subdir = getCurrentSubdir();
    info("disabling bugmail for $subdir");
    disableBugmail($subdir);

} elsif ($action eq 'reset-password') {
    my $subdir = getCurrentSubdir();
    my $login = shift @ARGV
        or die "syntax: bz reset-password <login>\n";
    info("resetting password for $login");
    resetPassword($subdir, $login);

} elsif ($action eq 'fix-all') {
    my $clean_params = dclone(\%PARAMS);
    foreach my $subdir (grep { -e "$_/localconfig" } glob("$HTDOCS_PATH/*")) {
        %PARAMS = %$clean_params;
        $subdir = basename($subdir);
        info("fixing $subdir");
        fixSubDir($subdir);
    }

} elsif ($action eq 'unfix') {
    my $subdir = getCurrentSubdir();
    info("unfix $subdir");
    unfix($subdir);

} elsif ($action eq 'drop-table') {
    my $subdir = getCurrentSubdir();
    @ARGV or die "syntax: bz drop-table <table>\n";
    dropTable($subdir, @ARGV);

} elsif ($action eq 'drop-column') {
    my $subdir = getCurrentSubdir();
    @ARGV or die "syntax: bz drop-column <table.column>\n";
    dropColumn($subdir, @ARGV);

} elsif ($action eq 'drop-cf') {
    my $subdir = getCurrentSubdir();
    @ARGV or die "syntax: bz drop-cf <custom_field>\n";
    dropCustomField($subdir, @ARGV);

} elsif ($action eq 'boilerplate' or $action eq 'bp') {
    my $subdir = getCurrentSubdir();
    addBoilerPlates($subdir, @ARGV);

} elsif ($action eq 'test') {
    my $subdir = getCurrentSubdir();
    info("running tests");
    checkForTabs($subdir);
    runTests($subdir, @ARGV);

} elsif ($action eq 'xt') {
    my $subdir = getCurrentSubdir();
    info("running xt tests");
    runXtTests($subdir, @ARGV);

} elsif ($action eq 'checksetup' or $action eq 'cs') {
    my $subdir = getCurrentSubdir();
    info("running checksetup");
    runChecksetup($subdir, @ARGV);

} elsif ($action eq 'grep') {
    my $query = "@ARGV";
    die("missing query string\n") if $query eq '';
    info("searching summaries for '$query'");
    grepSummaries($query);

} elsif ($action eq 'list') {
    my $subdir;
    eval { $subdir = getCurrentSubdir() };
    grepSummaries('', $subdir);

} elsif ($action eq 'info') {
    my $subdir = getCurrentSubdir();
    showInfo($subdir);

} elsif ($action =~ /^yui-(.+)/) {
    my $edition = $1;
    my $subdir = getCurrentSubdir();
    info("switching to yui-$edition");
    yui($subdir, $edition);

} elsif ($action eq 'mysql') {
    my $subdir = getCurrentSubdir();
    mysqlClient($subdir);

} else {
    usage($action ? "unknown action '$action'" : '');
}

sub usage {
    my ($error) = @_;

    alert("\n$error\n") if $error;

    my $parser = Pod::Text::Ansi->new(sentence => 0, width => 78);
    $parser->output_fh(*STDOUT);
    $parser->parse_lines(<DATA>);

    exit;
}

#

sub validateSubdir {
    my ($subdir) = @_;
    $subdir = lc($subdir || '');
    $subdir =~ s#^htdocs[\\|/]##;
    $subdir =~ s#[\\|/]$##;
    die("invalid directory '$subdir'\n") if $subdir eq '' || $subdir eq '.';
    return $subdir;
}

sub getCurrentSubdir {
    my $subdir = abs_path('.') . '/';
    die("invalid working directory: $subdir\n") unless $subdir =~ m#/htdocs/([^/]+)/#;
    $subdir = $1;
    return $subdir;
}

sub getCurrentRepoPath {
    my $path = abs_path(cwd());
    while (!-d "$path/.bzr") {
        my @dirs = File::Spec->splitdir($path);
        pop @dirs;
        $path = File::Spec->catdir(@dirs);
        die "cwd isn't a bzr repository\n" if $path eq '/';
    }
    return $path;
}

sub determineDefaultRepo {
    my ($subdir) = @_;

    my $default;
    if (dirToBugID($subdir)) {
        my $bug = getBugInfo(dirToBugID($subdir));
        if ($bug->{product} eq 'Bugzilla') {
            $default = $bug->{milestone};
            $default =~ s/^bugzilla //i;
            if ($default eq '---' || $default eq $BUGZILLA_TRUNK_MILESTONE) {
                $default = 'bugzilla/trunk';
            } else {
                $default = "bugzilla/$default";
            }
        } elsif ($bug->{product} eq 'bugzilla.mozilla.org') {
            $default = $DEFAULT_BMO_REPO;
        } else {
            info("unable to map " . $bug->{product} . " to a repo");
            $default = $DEFAULT_BMO_REPO;
        }

    } else {
        $default = $DEFAULT_BMO_REPO;
    }

    exit unless confirm("use default repository '$default'?");
    return $default;
}

sub determineDefaultDatabase {
    my ($subdir) = @_;

    my $default;
    if (dirToBugID($subdir)) {
        my $bug = getBugInfo(dirToBugID($subdir));
        if ($bug->{product} eq 'Bugzilla') {
            $default = $bug->{milestone};
            $default =~ s/^bugzilla //i;
            $default = 'trunk' if $default eq '---' || $default eq $BUGZILLA_TRUNK_MILESTONE;
        } elsif ($bug->{product} eq 'bugzilla.mozilla.org') {
            $default = $DEFAULT_BMO_DB;
        } else {
            info("unable to map " . $bug->{product} . " to a database");
            $default = $DEFAULT_BMO_DB;
        }

    } else {
        $default = $DEFAULT_BMO_DB;
    }

    $default = validateDatabase($default);
    exit unless confirm("use default database '$default'?");
    return $default;
}

sub validateRepo {
    my ($repo) = @_;
    $repo = lc($repo || '');
    $repo =~ s#^repo[\\|/]##;
    die("missing repo\n") if $repo eq '';
    my $found = 0;
    foreach my $try ("$repo", "bugzilla/$repo", "bmo/$repo") {
        if (-d "$REPO_PATH/$try") {
            $repo = $try;
            $found = 1;
            last;
        }
    }
    die "failed to find repo/$repo\n" unless $found;
    return $repo;
}

sub validateDatabase {
    my ($db) = @_;
    die "missing database\n" unless $db;
    $db = lc $db;
    $db =~ s/[\.-\/]/_/g;
    $db = "bugs_$db" unless $db =~ /^bugs_/;
    return $db;
}

sub validatePatch {
    my ($bug_id, $patch, $from_bug_id) = @_;
    $bug_id ||= '';

    if ($patch && $patch eq 'bug' && $from_bug_id) {
        $patch = '';
        $bug_id = $from_bug_id;
    } elsif ($bug_id eq 'bug' && $patch) {
        $bug_id = $patch;
        $patch = '';
    }

    if (!$patch && $bug_id =~ /^\d+$/) {
        info("fetching patches from bug $bug_id:");
        print getBugSummary($bug_id), "\n";
        my $proxy = getBmoProxy();
        my $response = $proxy->call('Bug.attachments', { ids => [ $bug_id ], exclude_fields => [ 'data' ] });
        soapErrChk($response);
        my @patches;
        foreach my $rh (@{$response->result->{bugs}->{$bug_id}}) {
            next unless $rh->{is_patch};
            next if $rh->{is_obsolete};
            push @patches, $rh;
        }
        if (scalar @patches < 10) {
            my $prompt = "  0. cancel\n";
            my $re = '0';
            for(my $i = 1; $i <= scalar @patches; $i++) {
                $prompt .= sprintf " %2s. %s\n", $i, $patches[$i - 1]->{summary};
                $re .= "$i";
            }
            $prompt .= '? ';
            my $no = prompt($prompt, qr/[$re]/i);
            exit if $no == 0;
            $patch = $patches[$no - 1]->{id};
        }
    }

    die("patch number or url missing\n") if !defined($patch) or $patch eq '';
    if ($patch =~ /id=(\d+)/) {
        $patch = $1;
    }
    die("invalid patch number\n") if $patch =~ /\D/;
    return $patch;
}

sub updateRepo {
    my ($repo) = @_;
    pushd("$REPO_PATH/$repo");
    info("updating repo $repo");
    fixRepo("$REPO_PATH/$repo", 1);
    system('bzr up');
    popd();
}

sub createSubDir {
    my ($subdir, $repo) = @_;
    return if -e "$HTDOCS_PATH/$subdir";
    die "invalid repo\n" unless -d "$REPO_PATH/$repo";
    info("creating $subdir directory");
    dircopy("$REPO_PATH/$repo", "$HTDOCS_PATH/$subdir") or die $!;
    foreach my $file (glob("$HTDOCS_PATH/$subdir/*.patch")) {
        unlink $file;
    }
    die "$HTDOCS_PATH/$subdir/checksetup.pl missing\n" unless -e "$HTDOCS_PATH/$subdir/checksetup.pl";
}

sub getCurrentDatabase {
    my ($subdir) = @_;
    createDefaultConfig($subdir);
    open(FH, "$HTDOCS_PATH/$subdir/localconfig") or die $!;
    my @file = <FH>;
    close FH;
    foreach my $line (@file) {
        next unless $line =~ /^\$db_name\s*=\s*'([^']+)'/;
        return $1;
    }
    return "unknown";
}

sub updateLocalConfig {
    my ($subdir, $database) = @_;
    $database ||= getCurrentDatabase($subdir);
    createDefaultConfig($subdir);
    open(FH, "$HTDOCS_PATH/$subdir/localconfig") or die $!;
    my @file = <FH>;
    close FH;
    $LOCALCONFIG{'db_name'} = $database;
    foreach my $line (@file) {
        next unless $line =~ /^\s*\$([\w_]+)\s*=\s*'([^']*)'/;
        my ($name, $value) = ($1, $2);
        if (exists $LOCALCONFIG{$name} && $LOCALCONFIG{$name} ne $value) {
            info("setting $name to $LOCALCONFIG{$name}");
            $line = "\$$name = '$LOCALCONFIG{$name}';\n";
        }
    }
    open(FH, ">$HTDOCS_PATH/$subdir/localconfig") or die $!;
    print FH @file;
    close FH;
}

sub createDefaultConfig {
    my ($subdir) = @_;
    return if -e "$HTDOCS_PATH/$subdir/localconfig";
    info("creating $HTDOCS_PATH/$subdir/localconfig");
    open(FH, ">$HTDOCS_PATH/$subdir/localconfig") or die $!;
    print FH <<'EOF';
$create_htaccess = 1;
$webservergroup = '';
$use_suexec = 0;
$db_driver = 'mysql';
$db_host = '';
$db_name = 'bugs';
$db_user = 'bugs';
$db_pass = '';
$db_port = 0;
$db_sock = '';
$db_check = 1;
$index_html = 0;
$cvsbin = '';
$interdiffbin = '';
$diffpath = '';
EOF
    close FH;
}

sub applyLocalPatches {
    my ($subdir) = @_;

    pushd("$HTDOCS_PATH/$subdir");

    foreach my $file (getLocalPatchFiles($subdir)) {
        info("applying patch from $file");
        system "patch --forward --strip=0 --input=$file --reject-file=- --batch";
    }

    if (!-e "extensions/LimitedEmailEx" && -e "extensions/LimitedEmail/disabled") {
        info("deploying limited-email extension");
        symlink("$REPO_PATH/LimitedEmailEx", "$HTDOCS_PATH/$subdir/extensions/LimitedEmailEx")
            or die $!;
    } elsif (-e "extensions/LimitedEmailEx" && !-e "extensions/LimitedEmail/disabled") {
        info("deleting limited-email extension");
        unlink("$HTDOCS_PATH/$subdir/extensions/LimitedEmailEx");
    }

    popd();
}

sub revertLocalPatches {
    my ($subdir) = @_;

    pushd("$HTDOCS_PATH/$subdir");
    foreach my $file (getLocalPatchFiles($subdir)) {
        system "patch --reverse --strip=0 --input=$file --reject-file=- --batch"
    }

    if (-e "extensions/LimitedEmailEx") {
        info("deleting limited-email extension");
        unlink("$HTDOCS_PATH/$subdir/extensions/LimitedEmailEx");
    }

    popd();
}

sub getLocalPatchFiles {
    my ($subdir) = @_;
    my @specs;
    push @specs, "$DATA_PATH/patches/shared/*.patch";
    push @specs, "$DATA_PATH/patches/" . getRepoBase($subdir) ."/*.patch";
    my @files;
    push @files, glob($_) foreach @specs;
    return @files;
}

sub deploySubdirPatch {
    my ($subdir, $patch) = @_;

    info("fetching patch $patch");
    my $proxy = getBmoProxy();

    my $response = $proxy->call('Bug.attachments', { attachment_ids => [ $patch ] });
    soapErrChk($response);

    my $attachments = $response->result->{attachments};
    die "failed to get attachment $patch information\n" unless exists $attachments->{$patch};
    my $attachment = $attachments->{$patch};
    printf STDERR "Bug %s: %s\n", $attachment->{bug_id}, $attachment->{description} || $attachment->{summary};
    die "attachment is not a patch\n" unless $attachment->{is_patch} == '1';
    die "attachment is obsolete\n" if $attachment->{is_obsolete} == '1';

    my $bug_id = $attachment->{bug_id};
    my $filename = "$bug_id-$patch.patch";
    my $content = $attachment->{data};
    $content =~ s/\015\012/\012/g;

    if (dirToBugID($subdir) && dirToBugID($subdir) != $bug_id) {
        my $summary = getBugSummary($bug_id);
        exit unless confirm("the patch from a different bug:\nBug $bug_id: $summary\ncontinue?");
    }

    pushd("$HTDOCS_PATH/$subdir");
    info("creating $filename");
    write_file($filename, { binmode => ':raw' }, $content);
    system("patch -p0 < $filename");
    popd();
}

sub deployRepoPatch {
    my ($repodir, $patch) = @_;

    info("fetching patch $patch");
    my $proxy = getBmoProxy();

    my $response = $proxy->call('Bug.attachments', { attachment_ids => [ $patch ] });
    soapErrChk($response);

    my $attachments = $response->result->{attachments};
    die "failed to get attachment $patch information\n" unless exists $attachments->{$patch};
    my $attachment = $attachments->{$patch};
    printf STDERR "Bug %s: %s\n", $attachment->{bug_id}, $attachment->{description} || $attachment->{summary};
    die "attachment is not a patch\n" unless $attachment->{is_patch} == '1';
    die "attachment is obsolete\n" if $attachment->{is_obsolete} == '1';
    my $reviewed = 0;
    foreach my $flag (@{$attachment->{flags}}) {
        if ($flag->{name} eq 'review' && $flag->{status} eq '+') {
            $reviewed = 1;
            last;
        }
    }
    die "attachment is not r+\n" unless $reviewed;

    my $bug_id = $attachment->{bug_id};
    my $filename = "$bug_id-$patch.patch";
    my $content = $attachment->{data};
    $content =~ s/\015\012/\012/g;

    pushd($repodir);
    info("creating $filename");
    write_file($filename, { binmode => ':raw' }, $content);
    system("patch -p0 < $filename");
    info("deleting $filename");
    unlink($filename);
    popd();
}

my %_bug_cache;

sub getBugInfo {
    my ($id) = @_;

    if (!exists $_bug_cache{$id}) {
        info("looking up bug $id");
        my $proxy = getBmoProxy();
        my $response = $proxy->call(
            'Bug.get',
            {
                ids => [ $id ],
                include_fields => [ 'id', 'product', 'version', 'target_milestone' ],
            }
        );
        soapErrChk($response);

        my $rh = $response->result->{bugs}->[0];
        $_bug_cache{$id} = {
            product => $rh->{product},
            version => $rh->{version},
            milestone => $rh->{target_milestone},
        };
    }

    return $_bug_cache{$id};
}

sub diff {
    my ($subdir, $bug, @files) = @_;
    die "Not a branch: $HTDOCS_PATH/$subdir\n" unless -e "$HTDOCS_PATH/$subdir/.bzr";
    pushd("$HTDOCS_PATH/$subdir");

    $bug = $1 if $bug =~ /^(\d+)_/;
    my $revision = 0;
    if ($bug ne '-') {
        foreach my $file (glob("${bug}_*.patch")) {
            next unless $file =~ /^\Q$bug\E_(\d+)\.patch$/;
            $revision = $1 if $1 > $revision;
        }
        $revision++;
    }

    unfix($subdir);
    my $patch = `bzr diff @files`;
    if ($bug eq '-') {
        print $patch;
    } else {
        print "creating ${bug}_$revision.patch\n";
        write_file("${bug}_$revision.patch", $patch);
    }
    fixSubDir($subdir);
    popd();
}

sub fixParams {
    my ($subdir) = @_;
    my $filename = "$HTDOCS_PATH/$subdir/data/params";
    return unless -e $filename;

    if (getRepoBase($subdir) eq 'bmo') {
        foreach my $name (keys %PARAMS_BMO) {
            $PARAMS{$name} = $PARAMS_BMO{$name};
        }
    }

    if ($subdir eq 'mod_perl') {
        $PARAMS{urlbase} = $MODPERL_BASE;
        $PARAMS{attachment_base} = $MODPERL_ATTACH_BASE;
        $PARAMS{cookiepath} = "/";
        $PARAMS{cookiedomain} = '';
    } else {
        $PARAMS{urlbase} = sprintf($PARAMS{urlbase}, $subdir);
        $PARAMS{attachment_base} = sprintf($PARAMS{attachment_base}, $subdir);
        $PARAMS{cookiepath} = "/$subdir/";
        $PARAMS{cookiedomain} = '';
    }
    
    $PARAMS{announcehtml} = getAnnounceHtml($subdir);

    my @file;
    open(FH, $filename) or die "failed to open $filename: $!\n";
    while (<FH>) {
        my $line = $_;
        foreach my $name (sort keys %PARAMS) {
            $line = fixParam($line, $name, $PARAMS{$name});
        }
        push @file, $line;
    }
    close FH;

    open(FH, ">$filename") or die $!;
    print FH @file;
    close FH;
}

sub getAnnounceHtml {
    my ($subdir) = @_;
    my $id = dirToBugID($subdir);
    my $db = getCurrentDatabase($subdir);
    my $dev_name = $id
        ? qq#<a href="https://bugzilla.mozilla.org/show_bug.cgi?id=$id"><b>Bug $id</b></a>#
        : "<b>$subdir</b>";
    my $summary = CGI::escapeHTML(getDirSummary($subdir));
    my $url = $URL_BASE;
    my $mail_warning = 
        -e "$HTDOCS_PATH/$subdir/extensions/LimitedEmailEx" || !-e "$HTDOCS_PATH/$subdir/extensions/LimitedEmail/disabled"
        ? ''
        : qq(<img src="${url}mail_warning.png" width="16" height="16">&nbsp;<b>Mail unrestricted</b><br>);
    my $announcehtml = <<EOF;
<div style="
background: url(${url}bkg_warning.png) repeat-y scroll left top #fff9db;
color: #666458;
padding: 5px 5px 5px 19px;
">
$mail_warning
$dev_name ($db) $summary
</div>
EOF
    $announcehtml =~ s/\n//g;
    return $announcehtml;
}

sub fixParam {
    my ($line, $name, $value) = @_;
    if ($line =~ /'\Q$name\E'\s*=>\s*('[^']*'|\d+),/) {
        my ($current) = ($1);
        $current =~ s/(^'|'$)//g;
        if ($current ne $value) {
            print "changing $name to '$value'\n";
            $line =~ s/'\Q$name\E'\s*=>\s*(?:'[^']*'|\d+),/'$name' => '$value',/;
        }
    }
    return $line;
}

sub fixHtAccess {
    my ($subdir) = @_;
    my $filename = "$HTDOCS_PATH/$subdir/.htaccess";
    my @file = -e $filename ? read_file($filename) : ();
    my $foundRewriteBase = 0;
    my $foundRewriteEngine = 0;
    foreach my $line (@file) {
        if ($line =~ /^\s*RewriteEngine\s+On/i) {
            $foundRewriteEngine = 1;
        }
        if ($line =~ /^\s*RewriteBase\s+\/([^\/]+)\//i) {
            $foundRewriteBase = $1;
        }
    }
    return if !$foundRewriteEngine || $foundRewriteBase eq $subdir;
    info("fixing .htaccess");
    my $i = 0;
    foreach my $line (@file) {
        $i++;
        next unless $line =~ /^\s*RewriteBase\s+/i;
        splice @file, $i - 1, 1;
        last;
    }
    $i = 0;
    foreach my $line (@file) {
        $i++;
        next unless $line =~ /^\s*RewriteEngine\s+On/i;
        splice @file, $i, 0, "RewriteBase /$subdir/\n";
        last;
    }
    write_file("$HTDOCS_PATH/$subdir/.htaccess", @file);
}

sub revertHtAccess {
    my ($subdir) = @_;
    my @file = read_file("$HTDOCS_PATH/$subdir/.htaccess");
    my $foundRewriteBase = 0;
    foreach my $line (@file) {
        if ($line =~ /^\s*RewriteBase\s+/i) {
            $foundRewriteBase = 1;
            last;
        }
    }
    return unless $foundRewriteBase;
    info("reverting .htaccess");
    my $i = 0;
    foreach my $line (@file) {
        $i++;
        next unless $line =~ /^\s*RewriteBase\s+/i;
        splice @file, $i - 1, 1;
        last;
    }

    my $content = join('', @file);
    $content =~ s/\015\012/\012/g;
    write_file("$HTDOCS_PATH/$subdir/.htaccess", { binmode => ':raw' }, $content);
}

sub deleteCrud {
    my ($subdir) = @_;
    my @crud_dirs;
    find(
        sub {
            my $filename = $File::Find::name;
            return unless
                $filename =~ /\~\d+\~$/
                || basename($filename) =~ /^\._/
                || $filename =~ /\.orig$/
                || $filename =~ /\.moved$/
                || $filename =~ /\.rej$/;
            my $name = $filename;
            $name =~ s#^\Q$HTDOCS_PATH/$subdir/##;
            print "deleting $name\n";
            if (-d $filename) {
                push @crud_dirs, $filename;
            } else {
                unlink($filename);
            }
        },
        "$HTDOCS_PATH/$subdir"
    );
    foreach my $dir (@crud_dirs) {
        rmdir($dir);
    }
    if (-d "$HTDOCS_PATH/$subdir/data/deleteme") {
        print "deleting data/deleteme\n";
        system (qq#rm -rf "$HTDOCS_PATH/$subdir/data/deleteme"#);
        if (-d "$HTDOCS_PATH/$subdir/data/deleteme") {
            system (qq#sudo rm -rf "$HTDOCS_PATH/$subdir/data/deleteme"#);
        }
    }
}

sub fixSubDir {
    my ($subdir) = @_;
    applyLocalPatches($subdir);
    fixParams($subdir);
    fixHtAccess($subdir);
    fixPerms($subdir);
    setRepoVersion($subdir);
    deleteCrud($subdir);
    updateLocalConfig($subdir);
    if (getCurrentDatabase($subdir) eq 'bugs') {
        alert("current database is 'bugs'");
    }
}

sub fixRepo {
    my ($path, $quick) = @_;
    $quick = 0 unless $quick;
    pushd($path);

    find(
        sub {
            my $file = $_;
            return if -d $file;
            if ($file =~ /\~\d+\~$/ || $file =~ /^\._/ || $file =~ /\.(orig|rej)$/) {
                print "deleting $file\n";
                unlink($file);
                return;
            }
            return if $quick;
            return unless -T $file;
            return if $file =~ /\/\.bzr\//;
            my $content = read_file($file, binmod => ':raw');
            return unless $content =~ /\015\012/;
            my $filename = $File::Find::name;
            $filename =~ s/^\.\///;
            print "converting $filename to unix line endings\n";
            $content =~ s/\015\012/\012/g;
            write_file($file, { binmod => ':raw' }, $content);
        },
        '.'
    );
    return if $quick;

    foreach my $line (`bzr diff`) {
        next unless $line =~ /modified file '([^']+)' \(properties changed: ([+-]x) to [+-]x\)/;
        my ($file, $perm) = ($1, $2);
        print "fixing permissions for $file\n";
        system "chmod $perm $file";
    }

    foreach my $file (`find . -type f -perm /111`) {
        chomp $file;
        next if $file =~ /\.(cgi|pl|swp)$/i;
        next if $file =~ /^\.\/contrib\//;
        print "fixing permissions for $file\n";
        system "chmod -x $file";
    }

    popd();
}

sub disableBugmail {
    my ($subdir) = @_;
    my $dbh = getDbh($subdir);
    $dbh->do("UPDATE profiles SET disable_mail=1");
}

sub resetPassword {
    my ($subdir, $login) = @_;
    pushd("$HTDOCS_PATH/$subdir");

    require Bugzilla;
    require Bugzilla::Install;
    Bugzilla::Install::reset_password($login);

    popd();
}

sub setRepoVersion {
    my ($subdir) = @_;
    pushd("$HTDOCS_PATH/$subdir");

    my $repo_version = '';
    if (-d '.bzr') {
        my $bzr = `bzr info`;
        if ($bzr =~ m#bzr\.mozilla\.org/((bugzilla|bmo)/.+)#) {
            $repo_version = trim($1);
            $repo_version =~ s#/$##;
            $repo_version =~ s#/#-#;
        }
    }
    if (getDirData($subdir, 'repo-version') ne $repo_version) {
        print "setting repo-version to $repo_version\n";
        setDirData($subdir, 'repo-version', $repo_version);
    }

    popd();
}

sub unfix {
    my ($subdir) = @_;
    revertHtAccess($subdir);
    fixAttributes($subdir);
    revertLocalPatches($subdir);
    yui($subdir, 'min');
    deleteCrud($subdir);
    fixParams($subdir);
}

sub dropTable {
    my ($subdir, @tables) = @_;

    my $dbh = getDbh($subdir);
    my $database = getCurrentDatabase($subdir);

    foreach my $table (@tables) {
        my ($exists) = $dbh->selectrow_array("
            SELECT 1
              FROM information_schema.tables
             WHERE table_schema = '$database'
                   AND table_name = '$table'
        ");
        if ($exists) {
            exit unless confirm("are you sure you want to drop the table '$table'?");
        }
    }

    info("loading schema");
    pushd("$HTDOCS_PATH/$subdir");
    my $bz_dbh = getBzDbh();
    my $schema = $bz_dbh->_bz_real_schema;

    foreach my $table (@tables) {
        if (!exists $schema->{abstract_schema}->{$table}) {
            die "failed to find table '$table' in bz_schema\n";
        }
    }
    foreach my $table (@tables) {
        info("dropping table '$table'");
        $dbh->do("DROP TABLE $table");
        delete $schema->{abstract_schema}->{$table};
    }

    info("updating bz_schema");
    $bz_dbh->_bz_store_real_schema();
    popd();
}

sub dropColumn {
    my ($subdir, @names) = @_;

    my $dbh = getDbh($subdir);
    my $database = getCurrentDatabase($subdir);
    my @columns;

    foreach my $name (@names) {
        if (scalar(split(/\./, $name)) != 2) {
            die "invalid column '$name'; use table.column\n";
        }
        my ($table, $column) = split(/\./, $name);
        my ($exists) = $dbh->selectrow_array("
            SELECT 1
              FROM information_schema.columns
             WHERE table_schema = '$database'
                   AND table_name = '$table'
                   AND column_name = '$column'
        ");
        if ($exists) {
            exit unless confirm("are you sure you want to drop the column '$table.$column'?");
        }
        push @columns, { table => $table, column => $column };
    }

    info("loading schema");
    pushd("$HTDOCS_PATH/$subdir");
    my $bz_dbh = getBzDbh();
    my $schema = $bz_dbh->_bz_real_schema;

    foreach my $rh (@columns) {
        my ($table, $column) = ($rh->{table}, $rh->{column});
        if (!exists $schema->{abstract_schema}->{$table}) {
            die "failed to find table '$table' in bz_schema\n";
        }
        my $table_schema = $schema->{abstract_schema}->{$table};
        my @fields = @{$table_schema->{FIELDS}};
        my $found = 0;
        for (my $i = 0; $i < scalar(@fields); $i += 2) {
            my ($name, $rh) = @fields[$i, $i + 1];
            if ($name eq $column) {
                $found = 1;
                last;
            }
        }
        if (!$found) {
            die "failed to find column '$column' in table '$table' in bz_schema\n";
        }
    }

    foreach my $rh (@columns) {
        my ($table, $column) = ($rh->{table}, $rh->{column});
        my $table_schema = $schema->{abstract_schema}->{$table};
        my @fields = @{$table_schema->{FIELDS}};
        info("dropping '$table.$column'");
        $dbh->do("ALTER TABLE $table DROP COLUMN $column");
        my @new_fields;
        for (my $i = 0; $i < scalar(@fields); $i += 2) {
            my ($name, $rh) = @fields[$i, $i + 1];
            if ($name ne $column) {
                push @new_fields, ($name, $rh);
            }
        }
        $schema->{abstract_schema}->{$table}->{FIELDS} = \@new_fields;
    }

    info("updating bz_schema");
    $bz_dbh->_bz_store_real_schema();
    popd();
}

sub dropCustomField {
    my ($subdir, @fields) = @_;
    pushd("$HTDOCS_PATH/$subdir");

    info("loading schema");
    my $dbh = getBzDbh();

    my @field_objs;
    foreach my $field (@fields) {
        my $field_obj;
        eval "
            use Bugzilla::Field;
            \$field_obj = new Bugzilla::Field({'name' => '$field'});
        ";
        die "invalid custom field '$field':\n$@\n" if $@;
        die "invalid custom field '$field'\n" unless $field_obj;
        exit unless confirm("are you sure you want to drop the custom field '$field'?");
        push @field_objs, $field_obj;
    }

    $dbh->bz_start_transaction;
    foreach my $field (@field_objs) {
        my $name = $field->name;
        info("deleting $name...");
        info("deleting from bugs_activity...");
        $dbh->do("DELETE FROM bugs_activity WHERE fieldid = " . $field->id);
        info("removing values from bugs...");
        $dbh->do("UPDATE bugs SET $name = NULL WHERE $name IS NOT NULL");
        info("dropping field...");
        $field->remove_from_db();
    }

    $dbh->bz_commit_transaction;
    popd();
}

sub getBzDbh {
    my ($subdir) = @_;
    my ($dbh);
    eval '
        use Bugzilla;
        $dbh = Bugzilla->dbh;
    ';
    initHandlers();
    return $dbh;
}

sub grepSummaries {
    my ($query, $subdir) = @_;
    pushd("$HTDOCS_PATH");
    my @dirs = grep { !-l $_ && -d $_ && -e "$_/data/summary" } glob('*');
    my $found = 0;
    foreach my $dir (@dirs) {
        my $summary = read_file("$dir/data/summary");
        next unless $summary =~ /\Q$query\E/i;
        if ($subdir && $dir eq $subdir) {
            info("$dir: $summary");
        } else {
            print "$dir: $summary\n";
        }
        $found = 1;
    }
    $found || print "no matches\n";
}

sub showInfo {
    my ($subdir) = @_;

    my $bzr_branch = '';
    my $filename = "$HTDOCS_PATH/$subdir/.bzr/branch/branch.conf";
    if (-e $filename) {
        my $conf = read_file($filename);
        ($bzr_branch) = $conf =~ /submit_branch\s*=\s*(.+)\n/;
        if (!$bzr_branch) {
            ($bzr_branch) = $conf =~ /bound_location\s*=\s*(.+)\n/;
        }
    }

    printf(
        '  ' . trim("
  subdir: %s
 summary: %s
    repo: %s
     bzr: %s
database: %s
 comment: %s
        ") . "\n",
        $subdir,
        getDirSummary($subdir) || '-',
        getDirData($subdir, 'repo-version') || '-',
        $bzr_branch || '-',
        getCurrentDatabase($subdir),
        getDirData($subdir, 'comment') || '-',
    );
}

sub mysqlClient {
    my ($subdir) = @_;

    my $localconfig = read_file("$HTDOCS_PATH/$subdir/localconfig");

    $localconfig =~ s/\n\$(\S+)/\n\$config{'$1'}/g;
    our %config;
    eval $localconfig;

    my $cmd = "mysql -h $config{db_host} ";
    $cmd .= "-P $config{db_port} " if $config{db_port};
    $cmd .= "-u $config{db_user} -p$config{db_pass} ";
    $cmd .= $config{db_name};

    system $cmd;
}

sub yui {
    my ($subdir, $edition) = @_;
    return unless -e "$HTDOCS_PATH/$subdir/js/yui/animation/animation-min.js";

    my $src = "$YUI_PATH/build";

    my $is_debug;
    {
        open(FH, "$HTDOCS_PATH/$subdir/js/yui/animation/animation-min.js")
            or die $!;
        my @lines = <FH>;
        close(FH);
        $is_debug = scalar @lines > 30;
    }
    return if $edition eq 'debug' && $is_debug;
    return if $edition eq 'min' && !$is_debug;
    
    find(
        sub {
            my $filename = $File::Find::name;
            $filename =~ s/^.*\Q$HTDOCS_PATH\/$subdir\/js\/yui\///;
            return unless $filename =~ /^(.+)-min(.+)/;
            my ($file, $ext) = ($1, $2);
            my $replacement;
            if ($edition eq 'debug') {
                if (-e "$src/$file$ext") {
                    $replacement = "$src/$file$ext";
                }
            } else {
                if (-e "$src/$file-min$ext") {
                    $replacement = "$src/$file-min$ext";
                }
            }
            die "failed to find replacement\n" unless $replacement;
            info("replacing $filename");
            copy($replacement, $File::Find::name)
                or die $!;
        },
        "$HTDOCS_PATH/$subdir/js/yui"
    );
}

sub checkForTabs {
    my ($subdir) = @_;

    my $root = "$HTDOCS_PATH/$subdir";
    my @invalid;
    my @ignore = qw(
        js/change-columns.js
        t/002goodperl.t
    );
    find(sub {
            my $file = $File::Find::name;
            return if -d $file;
            return unless -T $file;
            return if $file =~ /^\Q$root\E\/(\.bzr|contrib|data|js\/yui|docs)\//;
            return if $file =~ /\.patch$/;
            my $filename = $file;
            $filename =~ s/^\Q$root\E\///;
            return if grep { $_ eq $filename } @ignore;
            my $content = read_file($file);
            return unless $content =~ /\t/;
            push @invalid, $file;
        },
        "$HTDOCS_PATH/$subdir"
    );

    return unless scalar @invalid;
    alert('The following files contain tabs:');
    foreach my $filename (@invalid) {
        $filename =~ s/^\Q$root\E\///;
        alert($filename);
    }
    die "\n";
}

sub addBoilerPlates {
    my ($subdir, @files) = @_;

    if (!scalar @files) {
        my @added = getAddedFiles($subdir);
        foreach my $file (@added) {
            if (isMissingBoilerPlate("$HTDOCS_PATH/$subdir/$file")) {
                push @files, $file;
            }
        }
        die "no new files with missing boiler-plates\n" unless scalar @files;

    } elsif ($files[0] eq '-all') {
        @files = ();
        find(
            sub {
                my $name = $_;
                return if -d $name;
                return unless $name =~ /\./;
                return if $name =~ /\.swp$/;
                if (isMissingBoilerPlate($name)) {
                    my $file = abs_path($name);
                    $file =~ s/^$HTDOCS_PATH\/$subdir\///;
                    push @files, $file;
                }
            },
            '.'
        );
        die "no files with missing boiler-plates\n" unless scalar @files;
    }

    my $cwd = cwd();
    foreach my $file (@files) {
        if (-e $file) {
            $file = "$cwd/$file";
        }
        $file =~ s/^\Q$HTDOCS_PATH\/$subdir\/\E//;
    }

    pushd("$HTDOCS_PATH/$subdir");
    print "add boiler-plate to:\n";
    foreach my $file (@files) {
        next unless confirm("$file ?");
        my ($ext) = $file =~ /^.+\.(.+)$/;
        my $bp_file = "$DATA_PATH/boiler-plates/mpl.$ext";
        die "failed to find boilerplate for .$ext\n" unless -e $bp_file;
        my $bp = read_file($bp_file);
        $bp =~ s/20__/2011/g;
        # XXX need to place after #! line if present
        my $content = $bp . read_file($file);
        write_file($file, $content);
        print "$file updated\n";
    }
    popd();
}

sub getAddedFiles {
    my ($subdir) = @_;
    pushd("$HTDOCS_PATH/$subdir");
    my $in_added = 0;
    my @added_files;
    foreach my $line (`bzr st`) {
        chomp $line;
        if ($line =~ /^  (.+)/) {
            my $file = $1;
            next if $file =~ /\@$/;
            push @added_files, $file if $in_added && !-d $file;
        } else {
            $in_added = $line eq 'added:';
        }
    }
    popd();
    return @added_files;
}

sub isMissingBoilerPlate {
    my ($file) = @_;
    my $content = read_file($file);
    if ($content !~ /The contents of this file are subject to/ &&
        $content !~ /is subject to the terms of the/) {
        return 1;
    }
    return 0;
}

sub runChecksetup {
    my ($subdir, @args) = @_;
    pushd("$HTDOCS_PATH/$subdir");
    system "./checksetup.pl";
    popd();
}

sub runTests {
    my ($subdir, @args) = @_;
    pushd("$HTDOCS_PATH/$subdir");
    my @tests;
    if (scalar @args) {
        foreach my $arg (@args) {
            push @tests, glob("t/*$arg*.t");
        }
    } else {
        push @tests, glob("t/*.t");
    }
    runtests(@tests);
    popd();
}

sub runXtTests {
    my ($subdir, @args) = @_;
    pushd("$HTDOCS_PATH/$subdir");
    $ENV{BZ_WRITE_TESTS} = 1;
    runtests('xt/search.t');
    popd();
}

sub fixAttributes {
    my ($subdir) = @_;
    return unless -d "$HTDOCS_PATH/$subdir/.bzr";
    pushd("$HTDOCS_PATH/$subdir");
    foreach my $line (`bzr diff`) {
        next unless $line =~ /modified file '([^']+)' \(properties changed: ([+-]x) to [+-]x\)/;
        my ($file, $perm) = ($1, $2);
        info("fixing properties for $file");
        $file = '"' . $file . '"' if $file =~ / /;
        system("chmod $perm $file");
    }
    popd();
}

sub fixPerms {
    my ($subdir) = @_;
    pushd("$HTDOCS_PATH/$subdir");
    my @spec = glob('*');
    push @spec, '.htaccess';
    push @spec, '.bzr' if -d "$HTDOCS_PATH/$subdir/.bzr";
    my $user = getpwuid($>);
    system("chgrp -R --silent $LOCALCONFIG{webservergroup} @spec");
    @spec = grep { $_ ne 'data' } @spec;
    sudoOnOutput("chown -R $user @spec");
    sudoOnOutput('find . -path ./data -prune -type d -exec chmod g+x {} \;');
    foreach my $file (`find . -type f -perm /111`) {
        chomp $file;
        next if $file =~ /\.(cgi|pl|swp)$/;
        next if $file =~ /^\.\/contrib\//;
        info("fixing permissions for $file");
        $file = '"' . $file . '"' if $file =~ / /;
        sudoOnOutput("chmod -x $file");
    }
    popd();
}

sub sudoOnOutput {
    my ($command) = @_;
    my $output = `$command 2>&1`;
    if ($output) {
        info($command);
        die $output;
        info("escalating $command");
        system "sudo $command";
    }
}

sub getRepoBase {
    my ($subdir) = @_;
    my $repo_version = getDirData($subdir, 'repo-version');
    if (!$repo_version) {
        setRepoVersion($subdir);
    }
    $repo_version = getDirData($subdir, 'repo-version');

    if ($repo_version =~ /^bmo-/) {
        return 'bmo';
    } elsif ($repo_version =~ /^bugzilla-/) {
        return 'bugzilla';
    } else {
        die "unsupported repo_version: '$repo_version'";
    }
}

__DATA__

=head1 NAME

bz - tool for manipulating bugzilla development instances.

=head1 SYNOPSIS

=over 4

=item B<bz> B<new> I<subdir> I<repo> I<database>

create a new instance

=item B<bz> B<info>

displays information about the current instance

=item B<bz> B<list>

lists all instances

=item B<bz> B<patch> [I<attachment id>]
=item B<bz> B<patch> [I<attachment url>]
=item B<bz> B<patch> B<bug> [I<bug id>]

download and apply a patch

=item B<bz> B<new-patch> [I<patch number or url>]

revert current patch, then download and apply a patch

=item B<bz> B<diff> [-quick] [I<patch number>] [I<files>]

generate a diff against bzr; tests will be executed if I<-quick> is not specified

=item B<bz> B<db> [I<database>]

show or change the database

=item B<bz> B<fix>

various fixes to make the instance work (params, perms, etc)

=item B<bz> B<fix-all>

runs B<fix> on all instances

=item B<bz> B<bp> [I<file> | B<-all>]

prompts to add boiler plates to new files where it can't find one, or to the specified file
if you pass B<-all> it will prompt for all files under the cwd which are missing boiler plates

=item B<bz> B<unfix>

reverts fixes applied by B<fix>

=item B<bz> B<grep> I<query>

search summarys for the specified query

=item B<bz> B<test>

runs bugzilla's test suite

=item B<bz> B<checksetup> | B<cs>

runs bugzilla's checksetup.pl

=item B<bz> B<disable-bugmail>

disables bugmail for all users

=item B<bz> B<reset-password> I<login>

resets the password for a login, without running all the checksetup guff.

=item B<bz> B<drop-table> I<table> [I<table>...]

drops the table(s) from the schema and removes from bz_schema

=item B<bz> B<drop-cf> I<field> [I<field>...]

drops the custom field(s), removing from activity and bugs

=item B<bz> B<mysql>

runs mysql client connecting to the bugzilla database

=item B<bz> B<yui-debug>

switches the yui libs to -debug version

=item B<bz> B<yui-min>

switches the yui libs to -min version

=back
